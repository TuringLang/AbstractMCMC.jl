<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interface For Sampler state and Gibbs Sampling · AbstractMCMC</title><meta name="title" content="Interface For Sampler state and Gibbs Sampling · AbstractMCMC"/><meta property="og:title" content="Interface For Sampler state and Gibbs Sampling · AbstractMCMC"/><meta property="twitter:title" content="Interface For Sampler state and Gibbs Sampling · AbstractMCMC"/><meta name="description" content="Documentation for AbstractMCMC."/><meta property="og:description" content="Documentation for AbstractMCMC."/><meta property="twitter:description" content="Documentation for AbstractMCMC."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body>
<!-- NAVBAR START -->
<style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro&display=swap');

    /* Documenter.jl CSS Overrides */
    html {
        scroll-padding-top: calc(var(--navbar-height) + 1rem);
    }
    .docs-sidebar, #documenter {
        margin-top: var(--navbar-height);
    }
    .docs-version-selector {
        margin-bottom: 60px !important;
    }
    @media screen and (max-width: 1056px) {
        .docs-version-selector {
            margin-bottom: 60px !important;
        }
        .docs-sidebar {
            margin-top: 0 !important;
        }
    }
    /* End of Documenter.jl Tweaks */

    /* Color and Font Variables */
    :root {
        --heading-color: #6c757d;
        --item-color: rgb(165, 165, 165);
        --primary-bg: white;
        --hover-color: #8faad2;
        --deprecated-bg: #ff4d4d;
        --deprecated-text: white;
        --icon-color: #6c757d;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e9ecef;
        
        /* Typography */
        --font-family: "Source Sans Pro", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --nav-link-font-size: 1.0625rem;
        --turing-title-font-size: 21.25px;
        --icon-font-size: 1.25rem;
        --dropdown-arrow-font-size: 0.6875rem;
        --badge-font-size: 0.75rem;

        /* Sizing and Spacing */
        --navbar-height: 3.75rem;
        --logo-height: 31.18px;
        --logo-width: 52.47px;
        --logo-padding-top: 7px;
        --logo-margin-left: 0.3rem;
        --title-margin-left: 0.4px;
        --title-nav-spacing: 1.7rem;
        --nav-item-margin-left: 1.3rem;
        --icon-margin-left: 1rem;
        --dropdown-padding: 1.875rem;
        --dropdown-item-width: 12.5rem;
        --dropdown-subitem-width: 15.625rem;
        --dropdown-subitem-padding: 0.125rem 0.625rem;
    }

    /* Dark Theme Variable Overrides */
    html.theme--documenter-dark {
        --heading-color: #e0e0e0;
        --item-color: #bdbdbd;
        --primary-bg: #1f2424;
        --hover-color: #ffffff;
        --icon-color: #e0e0e0;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #424242;
    }

    /* Catppuccin Theme Overrides */
    html.theme--catppuccin-latte {
        --heading-color: #4c4f69;
        --primary-bg: #eff1f5;
        --icon-color: #4c4f69;
        --shadow-color: rgba(0, 0, 0, 0.1);
        --dropdown-hover-bg: #e6e9ef;
    }
    html.theme--catppuccin-frappe {
        --heading-color: #c6d0f5;
        --primary-bg: #303446;
        --icon-color: #c6d0f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #51576d;
    }
    html.theme--catppuccin-macchiato {
        --heading-color: #cad3f5;
        --primary-bg: #24273a;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #494d64;
    }
    html.theme--catppuccin-mocha {
        --heading-color: #cad3f5;
        --primary-bg: #1e1e2e;
        --icon-color: #cad3f5;
        --shadow-color: rgba(255, 255, 255, 0.1);
        --dropdown-hover-bg: #45475a;
    }


    /* Main Navigation Bar */
    .ext-navigation {
        font-family: var(--font-family);
        position: fixed;
        height: var(--navbar-height);
        top: 0;
        width: 100%;
        background-color: var(--primary-bg);
        z-index: 1000;
        box-shadow: 0 2px 4px var(--shadow-color);
        display: flex;
        align-items: center;
        padding: 0 1.0625rem;
        transition: transform 0.3s, background-color 0.3s;
    }

    nav.ext-navigation .ext-navbar-logo {
        margin-left: var(--logo-margin-left);
        height: var(--logo-height);
        width: var(--logo-width);
        padding-top: var(--logo-padding-top);
    }
    
    .ext-navbar-title {
        color: var(--heading-color) !important;
        font-size: var(--turing-title-font-size) !important;
        margin-left: var(--title-margin-left);
        text-decoration: none;
        transition: color 0.2s ease;
    }
    
    .ext-navbar-title:hover {
        color: var(--hover-color) !important;
    }

    .ext-nav-links {
        display: flex;
        align-items: center;
        list-style-type: none;
        margin: 0;
        padding: 0;
        flex-grow: 1;
        margin-left: var(--title-nav-spacing);
    }

    .ext-nav-links li:first-child {
        margin-left: 0 !important;
    }

    .ext-nav-links li {
        margin-left: var(--nav-item-margin-left) !important;
    }

    .ext-nav-link {
        color: var(--heading-color) !important;
        text-decoration: none;
        font-size: var(--nav-link-font-size) !important;
        transition: color 0.2s ease;
        cursor: pointer;
    }

    .ext-nav-link:hover,
    .ext-navbar-item-single a:hover,
    .ext-navbar-icons a:hover {
        color: var(--hover-color) !important;
    }

    .ext-navbar-item-single a {
        color: var(--heading-color) !important;
    }
    
    .ext-navbar-icons {
        display: flex;
        align-items: center;
    }

    .ext-navbar-icons a {
        color: var(--icon-color) !important;
        font-size: var(--icon-font-size) !important;
        transition: color 0.2s ease;
        margin-left: var(--icon-margin-left);
    }

    .ext-menu-toggle {
        display: none;
        font-size: 1.5rem;
        color: var(--heading-color);
        cursor: pointer;
    }

    .ext-dropdown {
        display: none;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        padding: var(--dropdown-padding);
        position: absolute;
        top: var(--navbar-height);
        width: 100%;
        left: 0;
        background-color: var(--primary-bg);
        line-height: 1.875rem;
        opacity: 0;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, background-color 0.3s;
        transform: translateY(-0.625rem);
        box-shadow: 0 4px 6px var(--shadow-color);
    }

    #library-handler::after {
        content: "▼";
        font-size: var(--dropdown-arrow-font-size);
        margin-left: 0.3125rem;
        transition: transform 0.3s ease-in-out;
    }

    #library-handler.open::after {
        content: "▲";
    }

    .ext-dropdown.show {
        display: grid;
        opacity: 1;
        transform: translateY(0);
    }

    .ext-dropdown ul {
        width: var(--dropdown-item-width);
        margin-bottom: 1.25rem;
    }

    .ext-dropdown ul li {
        text-align: left;
        display: flex;
        align-items: center;
    }

    .ext-dropdown ul a li {
        color: var(--item-color);
        width: var(--dropdown-subitem-width);
        border-radius: 3px;
        padding: var(--dropdown-subitem-padding);
        transition: background-color 0.2s ease;
    }

    .ext-dropdown ul a li:hover {
        background-color: var(--dropdown-hover-bg);
    }

    .ext-dropdown-item-heading {
        color: var(--heading-color);
        text-align: center;
    }

    .deprecated-badge {
        background-color: var(--deprecated-bg);
        color: var(--deprecated-text);
        font-size: var(--badge-font-size);
        padding: .1rem;
        border-radius: 3px;
        margin-left: 0.5rem;
        line-height: 1;
    }

    @media (max-width: 966px) {
        .ext-dropdown {
            grid-template-columns: 1fr 1fr 1fr;
        }
    }

    @media (max-width: 768px) {
        .ext-nav-links {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            background-color: var(--primary-bg);
            position: absolute;
            top: var(--navbar-height);
            left: 0;
            padding: 0.625rem 0;
            height: auto;
            overflow-y: auto;
            box-shadow: 0 4px 6px var(--shadow-color);
            margin-left: 0;
        }

        .ext-nav-links.show {
            display: flex;
        }

        .ext-nav-links li {
            margin: 0.625rem 0 !important;
            text-align: center;
        }
        
        .ext-menu-toggle {
            display: block;
            margin-left: auto;
        }

        .ext-navigation.hide {
            transform: translateY(calc(-1 * var(--navbar-height)));
        }

        .ext-dropdown {
            position: static;
            display: block;
            opacity: 1;
            transform: none;
            box-shadow: none;
            grid-template-columns: 1fr;
            padding: 0.625rem;
            text-align: center;
        }

        .ext-dropdown ul {
            width: auto;
            display: inline-block;
            margin: 0 auto 0.3125rem;
            text-align: left;
        }
    }
</style>
<nav class="ext-navigation">
    <a href="https://turinglang.org/">
        <img src="https://turinglang.org/assets/images/turing-logo.svg" alt="Turing Logo" class="ext-navbar-logo">
    </a>
    <a class="ext-navbar-title" href="https://turinglang.org/">Turing.jl</a>
    
    <ul class="ext-nav-links">
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/getting-started/">Get Started</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/tutorials/">Tutorials</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/docs/faq/">FAQ</a></li>
        <li>
            <p class="ext-nav-link" id="library-handler">Libraries</p>
            <div class="ext-dropdown" id="ext-dropdown-items">
                <ul>
                    <li class="ext-dropdown-item-heading">Modelling Languages</li>
                    <a href="https://turinglang.org/DynamicPPL.jl/"><li>DynamicPPL</li></a>
                    <a href="https://turinglang.org/JuliaBUGS.jl/"><li>JuliaBUGS</li></a>
                    <a href="https://turinglang.org/TuringGLM.jl/"><li>TuringGLM</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">MCMC</li>
                    <a href="https://turinglang.org/AdvancedHMC.jl/"><li>AdvancedHMC</li></a>
                    <a href="https://turinglang.org/AbstractMCMC.jl/"><li>AbstractMCMC</li></a>
                    <a href="https://github.com/theogf/ThermodynamicIntegration.jl"><li>ThermodynamicIntegration</li></a>
                    <a href="https://turinglang.org/AdvancedPS.jl/"><li>AdvancedPS</li></a>
                    <a href="https://turinglang.org/SliceSampling.jl/"><li>SliceSampling</li></a>
                    <a href="https://turinglang.org/EllipticalSliceSampling.jl/"><li>EllipticalSliceSampling</li></a>
                    <a href="https://turinglang.org/NestedSamplers.jl/"><li>NestedSamplers</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Diagnostics</li>
                    <a href="https://turinglang.org/MCMCChains.jl/"><li>MCMCChains</li></a>
                    <a href="https://turinglang.org/MCMCDiagnosticTools.jl/"><li>MCMCDiagnosticTools</li></a>
                    <a href="https://turinglang.org/ParetoSmooth.jl/"><li>ParetoSmooth</li></a>
                </ul>
                <ul>
                    <li class="ext-dropdown-item-heading">Gaussian Processes</li>
                    <a href="https://juliagaussianprocesses.github.io/AbstractGPs.jl/"><li>AbstractGPs</li></a>
                    <a href="https://juliagaussianprocesses.github.io/KernelFunctions.jl/"><li>KernelFunctions</li></a>
                    <a href="https://juliagaussianprocesses.github.io/ApproximateGPs.jl/"><li>ApproximateGPs</li></a>
                </ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Bijectors.jl/">Bijectors</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/TuringCallbacks.jl/">TuringCallbacks</a></li></ul>
                <ul><li class="ext-dropdown-item-heading ext-navbar-item-single"><a href="https://turinglang.org/Deprecated/TuringBenchmarking/">TuringBenchmarking</a><span class="deprecated-badge">Deprecated</span></li></ul>
            </div>
        </li>
        <li><a class="ext-nav-link" href="https://turinglang.org/news/">News</a></li>
        <li><a class="ext-nav-link" href="https://turinglang.org/team/">Team</a></li>
    </ul>

    <div class="ext-navbar-icons">
        <a href="https://x.com/TuringLang" aria-label="Turing on X"><i class="fa-brands fa-x-twitter"></i></a>
        <a href="https://discourse.julialang.org/c/domain/probprog/48" aria-label="Turing on Discourse"><i class="fa-brands fa-discourse"></i></a>
        <a href="https://julialang.slack.com/archives/CCYDC34A0" aria-label="Turing on Slack"><i class="fa-brands fa-slack"></i></a>
        <a href="https://github.com/TuringLang/" aria-label="Turing.jl on GitHub"><i class="fa-brands fa-github"></i></a>
    </div>

    <span class="ext-menu-toggle"><i class="fa-solid fa-bars"></i></span>
</nav>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        const menuToggle = document.querySelector(".ext-menu-toggle");
        const navLinks = document.querySelector(".ext-nav-links");
        const nav = document.querySelector(".ext-navigation");
        const libraryHandler = document.getElementById("library-handler");
        const dropdownContainer = document.getElementById("ext-dropdown-items");
        let lastScrollY = window.scrollY;

        function closeDropdown() {
            if (dropdownContainer.classList.contains("show")) {
                libraryHandler.classList.remove("open");
                dropdownContainer.classList.remove("show");
                setTimeout(() => {
                    if (!dropdownContainer.classList.contains("show")) {
                        dropdownContainer.style.display = "none";
                    }
                }, 300);
            }
        }

        function openDropdown() {
            dropdownContainer.style.display = "grid";
            libraryHandler.classList.add("open");
            setTimeout(() => {
                dropdownContainer.classList.add("show");
            }, 10);
        }

        function setAppropriateHeight() {
            if (window.innerWidth <= 768) {
                const viewportHeight = window.innerHeight;
                const navHeight = nav.offsetHeight;
                navLinks.style.maxHeight = `${viewportHeight - navHeight}px`;
                navLinks.style.overflowY = "auto";
            } else {
                navLinks.style.maxHeight = "";
                navLinks.style.overflowY = "";
            }
        }

        menuToggle.addEventListener("click", (event) => {
            event.stopPropagation();
            navLinks.classList.toggle("show");
            if (navLinks.classList.contains("show")) {
                setAppropriateHeight();
                closeDropdown();
                dropdownContainer.style.display = "none";
            }
        });

        libraryHandler.addEventListener("click", (event) => {
            event.stopPropagation();
            event.preventDefault();
            if (dropdownContainer.classList.contains("show")) {
                closeDropdown();
            } else {
                openDropdown();
            }
            setAppropriateHeight();
        });

        // Close all menus if a click is registered outside the navigation bar.
        document.addEventListener("click", (event) => {
            if (!nav.contains(event.target)) {
                navLinks.classList.remove("show");
                closeDropdown();
            }
        });

        // Hide navigation bar on scroll down in mobile view.
        window.addEventListener("scroll", () => {
            if (window.innerWidth <= 768) {
                if (window.scrollY > lastScrollY && window.scrollY > nav.offsetHeight){
                    nav.classList.add("hide");
                } else {
                    nav.classList.remove("hide");
                }
                lastScrollY = window.scrollY;
            }
        });

        window.addEventListener("resize", setAppropriateHeight);
    });
</script>
<!-- NAVBAR END -->


<div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbstractMCMC</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../design/">Design</a></li><li class="is-active"><a class="tocitem" href>Interface For Sampler <code>state</code> and Gibbs Sampling</a><ul class="internal"><li><a class="tocitem" href="#Using-the-state-Interface-for-block-sampling-within-Gibbs"><span>Using the <code>state</code> Interface for block sampling within Gibbs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Interface For Sampler <code>state</code> and Gibbs Sampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interface For Sampler <code>state</code> and Gibbs Sampling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TuringLang/AbstractMCMC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TuringLang/AbstractMCMC.jl/blob/master/docs/src/state_interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Interface-For-Sampler-state-and-Gibbs-Sampling"><a class="docs-heading-anchor" href="#Interface-For-Sampler-state-and-Gibbs-Sampling">Interface For Sampler <code>state</code> and Gibbs Sampling</a><a id="Interface-For-Sampler-state-and-Gibbs-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-For-Sampler-state-and-Gibbs-Sampling" title="Permalink"></a></h1><p>We encourage sampler packages to implement the following interface functions for the <code>state</code> type(s) they maintain:</p><pre><code class="language-julia hljs">LogDensityProblems.logdensity(logdensity_model::AbstractMCMC.LogDensityModel, state::MHState; recompute_logp=true)</code></pre><p>This function takes the logdensity model and the state, and returns the log probability of the state. If <code>recompute_logp</code> is <code>true</code>, it should recompute the log probability of the state. Otherwise, if available, it will use the log probability stored in the state. </p><pre><code class="language-julia hljs">Base.vec(state)</code></pre><p>This function takes the state and returns a vector of the parameter values stored in the state.</p><pre><code class="language-julia hljs">state = StateType(state::StateType, logp)</code></pre><p>This function takes an existing <code>state</code> and a log probability value <code>logp</code>, and returns a new state of the same type with the updated log probability.</p><p>These functions provide a minimal interface to interact with the <code>state</code> datatype, which a sampler package can optionally implement. The interface facilitates the implementation of &quot;meta-algorithms&quot; that combine different samplers. We will demonstrate this in the following sections.</p><h2 id="Using-the-state-Interface-for-block-sampling-within-Gibbs"><a class="docs-heading-anchor" href="#Using-the-state-Interface-for-block-sampling-within-Gibbs">Using the <code>state</code> Interface for block sampling within Gibbs</a><a id="Using-the-state-Interface-for-block-sampling-within-Gibbs-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-state-Interface-for-block-sampling-within-Gibbs" title="Permalink"></a></h2><p>In this sections, we will demonstrate how a <code>model</code> package may use this <code>state</code> interface to support a Gibbs sampler that can support blocking sampling using different inference algorithms.</p><p>We consider a simple hierarchical model with a normal likelihood, with unknown mean and variance parameters.</p><p class="math-container">\[\begin{align}
\mu &amp;\sim \text{Normal}(0, 1) \\
\tau^2 &amp;\sim \text{InverseGamma}(1, 1) \\
x_i &amp;\sim \text{Normal}(\mu, \sqrt{\tau^2})
\end{align}\]</p><p>We can write the log joint probability function as follows, where for the sake of simplicity for the following steps, we will assume that the <code>mu</code> and <code>tau2</code> parameters are one-element vectors. And <code>x</code> is the data.</p><pre><code class="language-julia hljs">using AbstractMCMC: AbstractMCMC # hide
using AbstractMCMC: AbstractMCMC # hide
function log_joint(; mu::Vector{Float64}, tau2::Vector{Float64}, x::Vector{Float64})
    # mu is the mean
    # tau2 is the variance
    # x is data

    # μ ~ Normal(0, 1)
    # τ² ~ InverseGamma(1, 1)
    # xᵢ ~ Normal(μ, √τ²)

    logp = 0.0
    mu = only(mu)
    tau2 = only(tau2)

    mu_prior = Normal(0, 1)
    logp += logpdf(mu_prior, mu)

    tau2_prior = InverseGamma(1, 1)
    logp += logpdf(tau2_prior, tau2)

    obs_prior = Normal(mu, sqrt(tau2))
    logp += sum(logpdf(obs_prior, xi) for xi in x)

    return logp
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">log_joint (generic function with 1 method)</code></pre><p>To make using <code>LogDensityProblems</code> interface, we create a simple type for this model.</p><pre><code class="language-julia hljs">abstract type AbstractHierNormal end

struct HierNormal{Tdata&lt;:NamedTuple} &lt;: AbstractHierNormal
    data::Tdata
end

struct ConditionedHierNormal{Tdata&lt;:NamedTuple,Tconditioned_vars&lt;:NamedTuple} &lt;:
       AbstractHierNormal
    data::Tdata

    &quot; The variable to be conditioned on and its value&quot;
    conditioned_values::Tconditioned_vars
end</code></pre><p>where <code>ConditionedHierNormal</code> is a type that represents the model conditioned on some variables, and</p><pre><code class="language-julia hljs">function AbstractPPL.condition(hn::HierNormal, conditioned_values::NamedTuple)
    return ConditionedHierNormal(hn.data, conditioned_values)
end</code></pre><p>then we can simply write down the <code>LogDensityProblems</code> interface for this model.</p><pre><code class="language-julia hljs">function LogDensityProblems.logdensity(
    hier_normal_model::ConditionedHierNormal{Tdata,Tconditioned_vars},
    params::AbstractVector,
) where {Tdata,Tconditioned_vars}
    variable_to_condition = only(fieldnames(Tconditioned_vars))
    data = hier_normal_model.data
    conditioned_values = hier_normal_model.conditioned_values

    if variable_to_condition == :mu
        return log_joint(; mu=conditioned_values.mu, tau2=params, x=data.x)
    elseif variable_to_condition == :tau2
        return log_joint(; mu=params, tau2=conditioned_values.tau2, x=data.x)
    else
        error(&quot;Unsupported conditioning variable: $variable_to_condition&quot;)
    end
end

function LogDensityProblems.capabilities(::HierNormal)
    return LogDensityProblems.LogDensityOrder{0}()
end

function LogDensityProblems.capabilities(::ConditionedHierNormal)
    return LogDensityProblems.LogDensityOrder{0}()
end</code></pre><h3 id="Implementing-A-Sampler-with-AbstractMCMC-Interface"><a class="docs-heading-anchor" href="#Implementing-A-Sampler-with-AbstractMCMC-Interface">Implementing A Sampler with <code>AbstractMCMC</code> Interface</a><a id="Implementing-A-Sampler-with-AbstractMCMC-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-A-Sampler-with-AbstractMCMC-Interface" title="Permalink"></a></h3><p>To illustrate the <code>AbstractMCMC</code> interface, we will first implement two very simple Metropolis-Hastings samplers: random walk and static proposal.</p><p>Although the interface doesn&#39;t force the sampler to implement <code>Transition</code> and <code>State</code> types, in practice, it has been the convention to do so.</p><p>Here we define some bare minimum types to represent the transitions and states.</p><pre><code class="language-julia hljs">struct MHTransition{T}
    params::Vector{T}
end

struct MHState{T}
    params::Vector{T}
    logp::Float64
end</code></pre><p>Next we define the  <code>state</code> interface functions mentioned at the beginning of this section.</p><pre><code class="language-julia hljs"># Interface 1: LogDensityProblems.logdensity
# This function takes the logdensity function and the state (state is defined by the sampler package)
# and returns the logdensity. It allows for optional recomputation of the log probability.
# If recomputation is not needed, it returns the stored log probability from the state.
function LogDensityProblems.logdensity(
    logdensity_model::AbstractMCMC.LogDensityModel, state::MHState; recompute_logp=true
)
    logdensity_function = logdensity_model.logdensity
    return if recompute_logp
        AbstractMCMC.LogDensityProblems.logdensity(logdensity_function, state.params)
    else
        state.logp
    end
end

# Interface 2: Base.vec
# This function takes a state and returns a vector of the parameter values stored in the state.
# It is part of the interface for interacting with the state object.
Base.vec(state::MHState) = state.params

# Interface 3: constructorof and MHState(state::MHState, logp::Float64)
# This function allows the state to be updated with a new log probability.
function MHState(state::MHState, logp::Float64)
    return MHState(state.params, logp)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MHState</code></pre><p>It is very simple to implement the samplers according to the <code>AbstractMCMC</code> interface, where we can use <code>LogDensityProblems.logdensity</code> to easily read the log probability of the current state.</p><pre><code class="language-julia hljs">abstract type AbstractMHSampler &lt;: AbstractMCMC.AbstractSampler end

&quot;&quot;&quot;
    RandomWalkMH{T} &lt;: AbstractMCMC.AbstractSampler

A random walk Metropolis-Hastings sampler with a normal proposal distribution. The field σ
is the standard deviation of the proposal distribution.
&quot;&quot;&quot;
struct RandomWalkMH{T} &lt;: AbstractMHSampler
    σ::T
end

&quot;&quot;&quot;
    IndependentMH{T} &lt;: AbstractMCMC.AbstractSampler

A Metropolis-Hastings sampler with an independent proposal distribution.
&quot;&quot;&quot;
struct IndependentMH{T} &lt;: AbstractMHSampler
    proposal_dist::T
end

# the first step of the sampler
function AbstractMCMC.step(
    rng::AbstractRNG,
    logdensity_model::AbstractMCMC.LogDensityModel,
    sampler::AbstractMHSampler,
    args...;
    initial_params,
    kwargs...,
)
    logdensity_function = logdensity_model.logdensity
    transition = MHTransition(initial_params)
    state = MHState(
        initial_params,
        only(LogDensityProblems.logdensity(logdensity_function, initial_params)),
    )

    return transition, state
end

@inline get_proposal_dist(sampler::RandomWalkMH, current_params::Vector{Float64}) =
    MvNormal(current_params, sampler.σ)
@inline get_proposal_dist(sampler::IndependentMH, current_params::Vector{T}) where {T} =
    sampler.proposal_dist

# the subsequent steps of the sampler
function AbstractMCMC.step(
    rng::AbstractRNG,
    logdensity_model::AbstractMCMC.LogDensityModel,
    sampler::AbstractMHSampler,
    state::MHState,
    args...;
    kwargs...,
)
    logdensity_function = logdensity_model.logdensity
    current_params = state.params
    proposal_dist = get_proposal_dist(sampler, current_params)
    proposed_params = rand(rng, proposal_dist)
    logp_proposal = only(
        LogDensityProblems.logdensity(logdensity_function, proposed_params)
    )

    if log(rand(rng)) &lt;
        compute_log_acceptance_ratio(sampler, state, proposed_params, logp_proposal)
        return MHTransition(proposed_params), MHState(proposed_params, logp_proposal)
    else
        return MHTransition(current_params), MHState(current_params, state.logp)
    end
end

function compute_log_acceptance_ratio(
    ::RandomWalkMH, state::MHState, ::Vector{Float64}, logp_proposal::Float64
)
    return min(0, logp_proposal - state.logp)
end

function compute_log_acceptance_ratio(
    sampler::IndependentMH, state::MHState, proposal::Vector{T}, logp_proposal::Float64
) where {T}
    return min(
        0,
        logp_proposal - state.logp + logpdf(sampler.proposal_dist, state.params) -
        logpdf(sampler.proposal_dist, proposal),
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">compute_log_acceptance_ratio (generic function with 2 methods)</code></pre><p>At last, we can proceed to implement a very simple Gibbs sampler.</p><pre><code class="language-julia hljs">struct Gibbs{T&lt;:NamedTuple} &lt;: AbstractMCMC.AbstractSampler
    &quot;Maps variables to their samplers.&quot;
    sampler_map::T
end

struct GibbsState{TraceNT&lt;:NamedTuple,StateNT&lt;:NamedTuple,SizeNT&lt;:NamedTuple}
    &quot;Contains the values of all parameters up to the last iteration.&quot;
    trace::TraceNT

    &quot;Maps parameters to their sampler-specific MCMC states.&quot;
    mcmc_states::StateNT

    &quot;Maps parameters to their sizes.&quot;
    variable_sizes::SizeNT
end

struct GibbsTransition{ValuesNT&lt;:NamedTuple}
    &quot;Realizations of the parameters, this is considered a \&quot;sample\&quot; in the MCMC chain.&quot;
    values::ValuesNT
end

&quot;&quot;&quot;
    update_trace(trace::NamedTuple, gibbs_state::GibbsState)

Update the trace with the values from the MCMC states of the sub-problems.
&quot;&quot;&quot;
function update_trace(
    trace::NamedTuple{trace_names}, gibbs_state::GibbsState{TraceNT,StateNT,SizeNT}
) where {trace_names,TraceNT,StateNT,SizeNT}
    for parameter_variable in fieldnames(StateNT)
        sub_state = gibbs_state.mcmc_states[parameter_variable]
        sub_state_params_values = Base.vec(sub_state)
        reshaped_sub_state_params_values = reshape(
            sub_state_params_values, gibbs_state.variable_sizes[parameter_variable]
        )
        unflattened_sub_state_params = NamedTuple{(parameter_variable,)}((
            reshaped_sub_state_params_values,
        ))
        trace = merge(trace, unflattened_sub_state_params)
    end
    return trace
end

function error_if_not_fully_initialized(
    initial_params::NamedTuple{ParamNames}, sampler::Gibbs{&lt;:NamedTuple{SamplerNames}}
) where {ParamNames,SamplerNames}
    if Set(ParamNames) != Set(SamplerNames)
        throw(
            ArgumentError(
                &quot;initial_params must contain all parameters in the model, expected $(SamplerNames), got $(ParamNames)&quot;,
            ),
        )
    end
end

function AbstractMCMC.step(
    rng::Random.AbstractRNG,
    logdensity_model::AbstractMCMC.LogDensityModel,
    sampler::Gibbs{Tsamplingmap};
    initial_params::NamedTuple,
    kwargs...,
) where {Tsamplingmap}
    error_if_not_fully_initialized(initial_params, sampler)

    model_parameter_names = fieldnames(Tsamplingmap)
    results = map(model_parameter_names) do parameter_variable
        sub_sampler = sampler.sampler_map[parameter_variable]

        variables_to_be_conditioned_on = setdiff(
            model_parameter_names, (parameter_variable,)
        )
        conditioning_variables_values = NamedTuple{Tuple(variables_to_be_conditioned_on)}(
            Tuple([initial_params[g] for g in variables_to_be_conditioned_on])
        )

        # LogDensityProblems&#39; `logdensity` function expects a single vector of real numbers
        # `Gibbs` stores the parameters as a named tuple, thus we need to flatten the sub_problem_parameters_values
        # and unflatten after the sampling step
        flattened_sub_problem_parameters_values = vec(initial_params[parameter_variable])

        sub_logdensity_model = AbstractMCMC.LogDensityModel(
            AbstractPPL.condition(
                logdensity_model.logdensity, conditioning_variables_values
            ),
        )
        sub_state = last(
            AbstractMCMC.step(
                rng,
                sub_logdensity_model,
                sub_sampler;
                initial_params=flattened_sub_problem_parameters_values,
                kwargs...,
            ),
        )
        (sub_state, size(initial_params[parameter_variable]))
    end

    mcmc_states_tuple = first.(results)
    variable_sizes_tuple = last.(results)

    gibbs_state = GibbsState(
        initial_params,
        NamedTuple{Tuple(model_parameter_names)}(mcmc_states_tuple),
        NamedTuple{Tuple(model_parameter_names)}(variable_sizes_tuple),
    )

    trace = update_trace(NamedTuple(), gibbs_state)
    return GibbsTransition(trace), gibbs_state
end

# subsequent steps
function AbstractMCMC.step(
    rng::Random.AbstractRNG,
    logdensity_model::AbstractMCMC.LogDensityModel,
    sampler::Gibbs{Tsamplingmap},
    gibbs_state::GibbsState;
    kwargs...,
) where {Tsamplingmap}
    trace = gibbs_state.trace
    mcmc_states = gibbs_state.mcmc_states
    variable_sizes = gibbs_state.variable_sizes

    model_parameter_names = fieldnames(Tsamplingmap)
    mcmc_states = map(model_parameter_names) do parameter_variable
        sub_sampler = sampler.sampler_map[parameter_variable]
        sub_state = mcmc_states[parameter_variable]
        variables_to_be_conditioned_on = setdiff(
            model_parameter_names, (parameter_variable,)
        )
        conditioning_variables_values = NamedTuple{Tuple(variables_to_be_conditioned_on)}(
            Tuple([trace[g] for g in variables_to_be_conditioned_on])
        )
        cond_logdensity = AbstractPPL.condition(
            logdensity_model.logdensity, conditioning_variables_values
        )
        cond_logdensity_model = AbstractMCMC.LogDensityModel(cond_logdensity)

        logp = LogDensityProblems.logdensity(
            cond_logdensity_model, sub_state; recompute_logp=true
        )
        sub_state = constructorof(typeof(sub_state))(sub_state, logp)
        sub_state = last(
            AbstractMCMC.step(
                rng, cond_logdensity_model, sub_sampler, sub_state; kwargs...
            ),
        )
        trace = update_trace(trace, gibbs_state)
        sub_state
    end
    mcmc_states = NamedTuple{Tuple(model_parameter_names)}(mcmc_states)

    return GibbsTransition(trace), GibbsState(trace, mcmc_states, variable_sizes)
end</code></pre><p>We are using <code>NamedTuple</code> to store the mapping between variables and samplers. The order will determine the order of the Gibbs sweeps. A limitation is that exactly one sampler for each variable is required, which means it is less flexible than Gibbs in <code>Turing.jl</code>.</p><p>We uses the <code>AbstractPPL.condition</code> to devide the full model into smaller conditional probability problems. And each conditional probability problem corresponds to a sampler and corresponding state.</p><p>The <code>Gibbs</code> sampler has the same interface as other samplers in <code>AbstractMCMC</code> (we don&#39;t implement the above state interface for <code>GibbsState</code> to keep it simple, but it can be implemented similarly).</p><p>The Gibbs sampler operates in two main phases:</p><ol><li><p>Initialization:</p><ul><li>Set up initial states for each conditional probability problem.</li></ul></li><li><p>Iterative Sampling: For each iteration, the sampler performs a sweep over all conditional probability problems:</p><p>a. Condition on other variables:</p><ul><li>Fix the values of all variables except the current one.</li></ul><p>b. Update current variable:</p><ul><li>Recompute the log probability of the current state, as other variables may have changed:<ul><li>Use <code>LogDensityProblems.logdensity(cond_logdensity_model, sub_state)</code> to get the new log probability.</li><li>Update the state with <code>sub_state = constructorof(typeof(sub_state))(sub_state, logp)</code> to incorporate the new log probability.</li></ul></li><li>Perform a sampling step for the current conditional probability problem:<ul><li>Use <code>AbstractMCMC.step(rng, cond_logdensity_model, sub_sampler, sub_state; kwargs...)</code> to generate a new state.</li></ul></li><li>Update the global trace:<ul><li>Extract parameter values from the new state using <code>Base.vec(new_sub_state)</code>.</li><li>Incorporate these values into the overall Gibbs state trace.</li></ul></li></ul></li></ol><p>This process allows the Gibbs sampler to iteratively update each variable while conditioning on the others, gradually exploring the joint distribution of all variables.</p><p>Now we can use the Gibbs sampler to sample from the hierarchical Normal model.</p><p>First we generate some data,</p><pre><code class="language-julia hljs">N = 100  # Number of data points
mu_true = 0.5  # True mean
tau2_true = 2.0  # True variance

x_data = rand(Normal(mu_true, sqrt(tau2_true)), N)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100-element Vector{Float64}:
  1.0296405455767241
 -1.9089061805471321
  0.27057997756013
  0.44058504873550974
  2.3282774585027015
 -0.3372589751482496
 -0.26201214041575077
  2.1209180512308374
  3.3024969362598737
  0.5611460397779461
  ⋮
 -1.054234745555553
 -0.5759767832965353
 -0.6124159632417515
  1.057941451364276
  2.6861807867581065
 -1.732802976088531
  0.2837758656007022
 -1.9787428159544154
 -0.9271422699748391</code></pre><p>Then we can create a <code>HierNormal</code> model, with the data we just generated.</p><pre><code class="language-julia hljs">hn = HierNormal((x=x_data,))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.HierNormal{@NamedTuple{x::Vector{Float64}}}((x = [1.0296405455767241, -1.9089061805471321, 0.27057997756013, 0.44058504873550974, 2.3282774585027015, -0.3372589751482496, -0.26201214041575077, 2.1209180512308374, 3.3024969362598737, 0.5611460397779461  …  2.1032744453069183, -1.054234745555553, -0.5759767832965353, -0.6124159632417515, 1.057941451364276, 2.6861807867581065, -1.732802976088531, 0.2837758656007022, -1.9787428159544154, -0.9271422699748391],))</code></pre><p>Using Gibbs sampling allows us to use random walk MH for <code>mu</code> and prior MH for <code>tau2</code>, because <code>tau2</code> has support only on positive real numbers.</p><pre><code class="language-julia hljs">samples = sample(
    hn,
    Gibbs((
        mu=RandomWalkMH(0.3),
        tau2=IndependentMH(product_distribution([InverseGamma(1, 1)])),
    )),
    10000;
    initial_params=(mu=[0.0], tau2=[1.0]),
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10000-element Vector{Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}}:
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.0], tau2 = [1.0]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.0], tau2 = [1.0]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [-0.00019554080633789396], tau2 = [1.0]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [-0.00019554080633789396], tau2 = [1.0]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.36509605748251567], tau2 = [1.519164741677156]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5327903775928816], tau2 = [1.897729904776983]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5327903775928816], tau2 = [1.897729904776983]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5237768537926436], tau2 = [1.897729904776983]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.4031951859908378], tau2 = [1.897729904776983]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.4124592676058667], tau2 = [1.897729904776983]))
 ⋮
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5286378709640328], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5286378709640328], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5286378709640328], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5286378709640328], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5286378709640328], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5561022399695073], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.5561022399695073], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.2925276830900206], tau2 = [2.445931334419155]))
 Main.GibbsTransition{@NamedTuple{mu::Vector{Float64}, tau2::Vector{Float64}}}((mu = [0.6321288176274122], tau2 = [2.445931334419155]))</code></pre><p>Then we can extract the samples and compute the mean of the samples.</p><pre><code class="language-julia hljs">warmup = 5000
thin = 10
thinned_samples = samples[(warmup + 1):thin:end]
mu_samples = [sample.values.mu for sample in thinned_samples]
tau2_samples = [sample.values.tau2 for sample in thinned_samples]

mu_mean = only(mean(mu_samples))
tau2_mean = only(mean(tau2_samples))
(mu_mean, tau2_mean)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.42934293071489593, 2.171811395749789)</code></pre><p>which is close to the true values <code>(5, 2)</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../design/">« Design</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 3 October 2024 15:54">Thursday 3 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

